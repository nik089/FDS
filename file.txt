FRONTEND INTERVIEW PRIORITY (OUT OF YOUR 25)
‚≠ê VERY IMPORTANT (Must Master ‚Äì 80% interview questions)

1.Brute Force Approach
2.Optimized Single Pass
3.Hashing (Map / Set)
4.Sliding Window Technique
5.Two Pointer Technique
7.Stack (LIFO)
6.Sorting + Custom Comparator
8.Recursion (basic)
9.Memoization / Caching
10.Debounce
11. Throttle
12.State / Space Optimization

üëâ These alone can clear most frontend interviews.

============================================================
MEDIUM PRIORITY (Know concept + basic example)
============================================================

13.Prefix Sum

14.Binary Search

15.Queue (FIFO)

16.Greedy Algorithm

17.In-Place Algorithm




| Technique      | Time Complexity | Space Complexity | Interview Use   |
| -------------- | --------------- | ---------------- | --------------- |
| Brute Force    | O(n¬≤)           | O(1)             | Explain first   |
| Single Pass    | O(n)            | O(1)             | Optimal         |
| Hashing        | O(n)            | O(n)             | Fast lookup     |
| Sliding Window | O(n)            | O(1) / O(k)      | Subarrays       |
| Two Pointer    | O(n)            | O(1)             | Pairs / reverse |

======================================================================================
| Problem Type         | Choose         |
| -------------------- | -------------- |
| Reverse / palindrome | Two Pointer    |
| Pair sum (sorted)    | Two Pointer    |
| Subarray / substring | Sliding Window |
| Count / frequency    | Hashing        |
| Negative numbers     | Hashing        |
| Continuous window    | Sliding Window |

==============================================================
Sliding Window concept
==============================================================
2Ô∏è‚É£ What is a Continuous Window?
[1, 2, 3, 4, 5]
                [1,2,3]  ‚Üê window
                    [2,3,4]
                        [3,4,5]
========================================================
3Ô∏è‚É£ Continuous Window in Strings (Substring)
"abcdef"
        Continuous substrings ‚úÖ
                    "abc"
                    "bcd"
                    "cde"

NOT continuous ‚ùå
                    "ace"
                    "adf"

üëâ Substring always means continuous
üëâ Subsequence means NOT continuous
================================================================
4Ô∏è‚É£ Why Continuous Window is Important?

        Because Sliding Window ONLY works on continuous data.
        Sliding Window assumes:
        Removing left element changes window correctly
        Adding right element extends window correctly
        This is possible only if elements are continuous.

5Ô∏è‚É£ When You SHOULD Use Sliding Window
    | Keyword     | Meaning            | Example                                  |
    | ----------- | ------------------ | ---------------------------------------- |
    | subarray    | continuous array   | [2, 5, 7] is a subarray of [1, 2, 5, 7]   |
    | substring   | continuous string  | "abc" is a substring of "zabcx"          |
    | window      | continuous range   | Current window: indexes 2 ‚Üí 5            |
    | consecutive | next to each other | 4, 5, 6 are consecutive numbers          |
    | range       | continuous         | Values between index 1 and 4             |


7Ô∏è‚É£ Continuous Window vs Non-Continuous (Very Important)

| Problem Type    | Continuous? | Technique               | Example                                                      |
| --------------- | ----------- | ----------------------- | ------------------------------------------------------------ |
| Subarray        | ‚úÖ           | Sliding Window          | In [1, 2, 3, 4, 5], the subarray [2, 3, 4]                   |
| Substring       | ‚úÖ           | Sliding Window          | In "abracadabra", the substring "bra"                        |
| Pair sum        | ‚ùå           | Two Pointer / Hashing   | From [2, 7, 11, 15], pair (2, 7) ‚Üí target = 9                |
| Frequency count | ‚ùå           | Hashing                 | For "aabbc", frequency = { a:2, b:2, c:1 }                   |
| Reverse array   | ‚ùå           | Two Pointer             | [1, 2, 3, 4] ‚Üí reversed ‚Üí [4, 3, 2, 1]                       |

================================================================================================

| Type   | Input                     | Window Example        | Continuous? | Why                                               |
|------- |-------------------------- |---------------------- |------------ |--------------------------------------------------|
| Array  | [2, 1, 5, 1, 3, 2]        | [1, 5, 1]             | ‚úÖ Yes      | Elements come from indexes 1 ‚Üí 3 with no gaps    |
| Array  | [2, 1, 5, 1, 3, 2]        | [2, 5, 3]             | ‚ùå No       | Skips indexes (0,2,4) ‚Äî not side-by-side         |
| Array  | [4, 6, 8, 9]              | [6, 8]                | ‚úÖ Yes      | Adjacent elements (indexes 1 ‚Üí 2)                |
| Array  | [4, 6, 8, 9]              | [4, 8]                | ‚ùå No       | Jumped from index 0 ‚Üí 2                          |
| String | "abcdef"                  | "bcd"                 | ‚úÖ Yes      | Characters are next to each other                |
| String | "abcdef"                  | "ace"                 | ‚ùå No       | Skips characters (b and d)                       |
| String | "abracadabra"             | "rac"                 | ‚ùå No       | Not found as a single continuous chunk           |
| String | "abracadabra"             | "bra"                 | ‚úÖ Yes      | Appears together exactly as written              |
===================================================================================================================================


üîü Final Golden Rule (VERY IMPORTANT)
Sliding Window = Continuous elements only
Non-continuous = Hashing or Two Pointer

======================================================================================================

‚ö†Ô∏è Interview Trap to Avoid
‚ùå Saying ‚ÄúHashing is always best‚Äù
‚ùå Ignoring space complexity
‚ùå Using sliding window for non-continuous data



=============================================================================
Two Pointer vs Hashing ‚Äî When to Choose Which?
1Ô∏è‚É£ Decision Table (WITH EXAMPLES)

| Situation / Requirement      | Choose Two Pointer | Choose Hashing | **WHY (Clear Reason)**              | **Array Example**    | **String Example**   |
| ---------------------------- | ------------------ | -------------- | ----------------------------------- | -------------------- | -------------------- |
| Data is **sorted**           | ‚úÖ                  | ‚ùå              | Order helps move pointers logically | Two Sum: `[1,2,3,4]` | N/A                  |
| Data is **unsorted**         | ‚ùå                  | ‚úÖ              | No order ‚Üí need lookup memory       | Two Sum: `[3,2,4]`   | Anagram check        |
| Need **O(1) space**          | ‚úÖ                  | ‚ùå              | No extra data structure             | Reverse `[1,2,3]`    | Palindrome `"madam"` |
| Need **fast lookup**         | ‚ùå                  | ‚úÖ              | Hash gives O(1) access              | Duplicate `[1,2,1]`  | First repeating char |
| Need **frequency count**     | ‚ùå                  | ‚úÖ              | Must store counts                   | `[1,1,2,2]`          | `"aabbc"`            |
| Compare from **both ends**   | ‚úÖ                  | ‚ùå              | Natural left/right comparison       | Reverse array        | Palindrome           |
| Elements can be **negative** | ‚ùå                  | ‚úÖ              | Pointer logic breaks                | `[1,-1,2]` sum       | N/A                  |
| Pair / swap / reverse        | ‚úÖ                  | ‚ùå              | Direct pointer swap                 | Move zeros           | Reverse string       |
| Order must stay **same**     | ‚ùå                  | ‚úÖ              | Two pointer often mutates           | First duplicate      | First unique char    |
| Memory is **limited**        | ‚úÖ                  | ‚ùå              | Hashing uses extra memory           | Large array          | Large string         |

====================================================================================================================
5Ô∏è‚É£ Time & Space Comparison Table

| Technique   | Time | Space | Best Use                    |
| ----------- | ---- | ----- | --------------------------- |
| Two Pointer | O(n) | O(1)  | Sorted data, pairs, reverse |
| Hashing     | O(n) | O(n)  | Lookup, frequency, unsorted |

6Ô∏è‚É£ Interview One-Line Rules (MEMORIZE)
        Sorted data ‚Üí Two Pointer
        Unsorted + lookup ‚Üí Hashing
        Low memory needed ‚Üí Two Pointer
        Need count or frequency ‚Üí Hashing
